class TrieNode:
    CAT_DICTIONARY_SIZE = 26
    def __init__(self, char: str):
        """
        Function description: create a trie node with a character and a list of children nodes (initially empty)
        no children added, is_end_of_word is True
        :Input:
        char: character of the node
        :Output, return or postcondition: a trie node
        :Time complexity: O(1) - cat dictionary is constant size
        :Aux space complexity: O(1) - cat dictionary is constant size
        """
        # normal node
        if char:        
            self.char = char
        # root node
        else: 
            self.char = "None"
        
        # tracking how many times node completes a sentence
        self.end_of_word = 0

        self.children = [None for i in range(self.CAT_DICTIONARY_SIZE)]


    def add_child(self, child):
        """
        Function description: add a child to the node node
        as the child is added, is_end_of_word is False
        :Input:
        child: a trie node
        :Output, return or postcondition: none
        :Time complexity: O(1)
        :Aux space complexity: O(0)
        """
        self.children[child.get_char_index()] = child

    def ends_sentence(self):
        """
        Function description: add an end of word counter to node
        :Input: NA
        :Output, return or postcondition: none
        :Time complexity: O(1)
        :Aux space complexity: O(0)
        """
        self.end_of_word += 1
    
    def get_end_of_sentence_count(self):
        """
        Function description: get the end of word counter
        :Input: NA
        :Output, return or postcondition: int representing the end of word counter
        :Time complexity: O(1)
        :Aux space complexity: O(0)
        """
        return self.end_of_word
    
    def get_child(self, char: str):
        """
        Function description: get a child to the node node by character
        :Input:
        char: a character
        :Output, return or postcondition: trie node or None representing the child
        :Time complexity: O(1)
        :Aux space complexity: O(0)
        """
        return self.children[ord(char) - ord('a')]
    
    #first attempt
        
    """def auto_complete(self, prefix: str):
        Function description: auto complete the prefix
        Approach description: find the node that represents the last character in the prefix, then traverse the trie
        from that node to find all the words that can be auto completed
        :Input:
        prefix: a string representing the prefix
        :Output, return or postcondition: a list of strings representing the words that can be auto completed
        :Time complexity: O(X + Y) where X is the number of words in the prefix and Y is the length of the completion
        :Aux space complexity: O(Y) where Y is the length of the completion
        node = self
        for char in prefix:
            node = node.get_child(char)
            if not node:
                return None
        return self.auto_complete_aux(node, prefix)
    
    def auto_complete_aux(self, node, results=[], max_occurrences=1):
        Function description: auto complete the prefix, helper recursive function
        :Input:
        node: a trie node
        prefix: a string representing the prefix
        :Output, return or postcondition: a list of strings representing the words that can be auto completed
        :Time complexity: O(n) where n is the number of nodes in the trie
        :Aux space complexity: O(n) where n is the number of nodes in the trie
        # if we have found a valid sentence
        if node.get_end_of_sentence_count() > 0:
            # if that sentence occurs more than other sentences
            if node.get_end_of_sentence_count() > max_occurrences:
                max_occurrences = node.get_end_of_sentence_count()
        

        for child in node.children:
            if child:
                result.extend(self.auto_complete_helper(child, results, max_occurrences))

        return result"""

    def get_char_index(self):
        """
        Function description: get the index of the character in the cat dictionary to map to the children list
        :Input: NA
        :Output, return or postcondition: int representing the index of the character in the cat dictionary
        :Time complexity: O(1)
        :Aux space complexity: O(0)
        """
        return ord(self.char) - ord('a')
    
    def __str__(self):
        """
        Function description: returns a string representation of the node
        :Input: NA
        :Output: string representation of the node
        :Time complexity: O(1)
        :Aux space complexity: O(0)
        """
        return self.char
    
    def visualise(self):
        """
        Function description: visualise the trie
        :Input: NA
        :Output: NA
        :Time complexity: O(n) where n is the number of nodes in the trie
        :Aux space complexity: O(0)
        """
        self.visualise_aux(self, 0)
    
    def visualise_aux(self, node, level):
        """
        Function description: visualise the trie
        :Input: 
        node: a trie node
        level: int representing the level of the node in the trie
        :Output: NA
        :Time complexity: O(n) where n is the number of nodes in the trie
        :Aux space complexity: O(0)
        """
        if node:
            print(' ' * level, node)
            for child in node.children:
                self.visualise_aux(child, level + 1)



class CatsTrie:
    CAT_DICTIONARY_SIZE = 26
    def __init__(self, sentences: list):
        self.sentences = sentences
        self.trie = TrieNode(None)
        self.build_trie()
    
    def build_trie(self):
        for sentence in self.sentences:
            self.add_sentence(sentence)

    def add_sentence(self, sentence: str):
        node = self.trie
        for char in sentence:
            if not node.get_child(char):
                node.add_child(TrieNode(char))
            node = node.get_child(char)
        # keeping track of number of times a sentence is added
        node.ends_sentence()

    def autocomplete(self, prefix: str):
        from collections import deque

        # get to the last node of the prefix
        node = self.trie
        for char in prefix:
            index = ord(char) - ord('a')
            if node.children[index] is None:
                return []
            node = node.children[index]

        completion = ""
        queue = deque([(node, prefix)])

        # need to keep track of the sentence with the most occurences, and in case of ties, shortest
        occurences = 0
        length = 0

        # BFS to find all subtrees of the prefix
        while queue:
            node, word = queue.popleft()

            # Check if the node represents a complete sentence that is a better completion than the current sentence
            if node.end_of_word > occurences:
                completion = word
                length = len(word)
                occurences = node.end_of_word
            elif node.end_of_word == occurences:
                if len(word) < length:
                    completion = word
                    length = len(word)

            # Add child nodes to the queue
            for i, child in enumerate(node.children):
                if child is not None:
                    char = chr(ord('a') + i)
                    queue.append((child, word + char))

        return completion



# main
if __name__ == '__main__':
    sentences = ["abc", "abazacy", "dbcef", "xzz", "gdbc", "abazacy", "xyz", "abazacy", "dbcef", "xyz", "xxx", "xzz"]
    cats_trie = CatsTrie(sentences)
    cats_trie.trie.visualise()
    print()
    print(cats_trie.autocomplete('d'))