class TrieNode:
    CAT_DICTIONARY_SIZE = 26
    def __init__(self, char: str):
        """
        Function description: create a trienode with a character and a list of children nodes (initially empty), 
        and a counter to indicate how many times the node completes a sentence
        :Input:
        char: character of the node
        :Output, return or postcondition: TrieNode object
        :Time complexity: O(1) - cat dictionary is constant size
        :Aux space complexity: O(1) - cat dictionary is constant size
        """
        # normal node
        if char:        
            self.char = char
        # root node
        else: 
            self.char = "None"
        
        # tracking how many times node completes a sentence
        self.end_of_word = 0

        self.children = [None for i in range(self.CAT_DICTIONARY_SIZE)]


    def add_child(self, child):
        """
        Function description: add a child to the TrieNode object based on the character index of the child
        :Input:
        child: a TrieNode
        :Output, return or postcondition: the index of the character in the children list points to the child TrieNode
        :Time complexity: O(1)
        :Aux space complexity: O(0)
        """
        self.children[child.get_char_index()] = child

    def ends_sentence(self):
        """
        Function description: add an end of word counter to node
        :Input: NA
        :Output, return or postcondition: the current node end of word counter is incremented by 1
        :Time complexity: O(1)
        :Aux space complexity: O(0)
        """
        self.end_of_word += 1
    
    def get_child(self, char: str):
        """
        Function description: get a child to the node by character
        :Input:
        char: a character
        :Output, return or postcondition: TrieNode or None representing the child
        :Time complexity: O(1)
        :Aux space complexity: O(0)
        """
        return self.children[ord(char) - ord('a')]
    
    def get_char_index(self):
        """
        Function description: get the index of the character in the cat dictionary to map to the children list
        :Input: NA
        :Output, return or postcondition: int representing the index of the character in the cat dictionary
        :Time complexity: O(1)
        :Aux space complexity: O(0)
        """
        return ord(self.char) - ord('a')
    
    def __str__(self):
        """
        Function description: returns a string representation of the node, used for visualisation
        :Input: NA
        :Output: string representation of the node
        :Time complexity: O(1)
        :Aux space complexity: O(0)
        """
        return self.char
    
    def visualise(self):
        """
        Function description: visualise the Trie
        :Input: NA
        :Output: NA
        :Not doing complexity this is just for me:
        """
        self.visualise_aux(self, 0)
    
    def visualise_aux(self, node, level):
        """
        Function description: visualise the trie
        :Input: 
        node: a trie node
        level: int representing the level of the node in the trie
        :Output: NA
        :Not doing complexity this is just for me:
        """
        if node:
            print(' ' * level, node)
            for child in node.children:
                self.visualise_aux(child, level + 1)



class CatsTrie:
    CAT_DICTIONARY_SIZE = 26
    def __init__(self, sentences: list):
        """
        Function description: create a CatsTrie with the sentences given
        CatsTrie is a Trie graph of the sentences given, with each node representing a word in the cat dictionary
        :Input:
        sentences: list of strings representing the sentences to be added to the trie
        :Output, return or postcondition: CatsTrie object
        :Time complexity: O(N*M) where N is the number of sentences and M is the length of the longest sentence
        :Aux space complexity: O(N*M)
        """
        self.sentences = sentences
        self.trie = TrieNode(None)
        self.build_trie() # O(N*M)
    
    def build_trie(self):
        for sentence in self.sentences: # O(N) where N is the number of sentences
            self.add_sentence(sentence) # O(M)

    def add_sentence(self, sentence: str):
        """
        Function description: add a sentence to the CatsTrie
        :Input:
        sentence: string representing the sentence to be added to the trie
        :Output, return or postcondition: sentence given is found in CatsTrie, or if already found, the end of word counter for
         the final node is incremented
        :Time complexity: O(M) where M is the length of the longest sentence
        :Aux space complexity: O(1)
        """
        node = self.trie
        for char in sentence: # worst case O(M) where M is the length of the longest sentence
            if not node.get_child(char):
                node.add_child(TrieNode(char))
            node = node.get_child(char)
        # keeping track of number of times a sentence is added
        node.ends_sentence()

    def autocomplete(self, prefix: str):
        """
        Function description: autocomplete a sentence given a prefix
        Approach description: my approach uses a BFS to traverse all the subtrees of the prefix. It keeps track of the current best
        completion and the number of occurences of the current best completion. It then compares the current best completion with
        the current node's completion and updates the current best completion if the current node's completion is better (i.e. has
        more occurences). If the current node's completion is the same as the current best completion, then the lexigraphically
        smaller one is chosen. 
        :Input:
        prefix: string representing the prefix of the sentence to be autocompleted 
        :Output, return or postcondition: string representing the best completion of the prefix
        :Time complexity: O(X + Y) where X is the length of the prefix and Y is the length of the most frequent completion of the prefix
        :Aux space complexity: O(X + Y) where X is the length of the prefix and Y is the length of the most frequent completion of the prefix
        """
        from collections import deque

        # get to the last node of the prefix - O(X) where X is the length of the prefix
        node = self.trie
        for char in prefix:
            index = ord(char) - ord('a')
            if node.children[index] is None:
                return None
            node = node.children[index]

        completion = ""
        queue = deque([(node, prefix)])

        # need to keep track of how many occurences the current best completion has
        occurences = 0

        # BFS to traverse all subtrees of the prefix
        while queue:
            node, word = queue.popleft()

            # Check if the node represents a complete sentence that is a better completion than the current sentence
            if node.end_of_word > occurences:
                completion = word
                occurences = node.end_of_word
            elif node.end_of_word == occurences and node.end_of_word != 0:
                if word < completion: # lexicographical size
                    completion = word

            # Add child nodes to the queue
            for i, child in enumerate(node.children): # O(26) = O(1)
                if child is not None:
                    char = chr(ord('a') + i)
                    queue.append((child, word + char))

        return completion



# main
if __name__ == '__main__':
    sentences = ["abc", "abczacy", "dbcef", "xzz", "gdbc", "abczacy", "xyz", "abczacy", "dbcef", "xyz", "xxx", "xzz"]
    cats_trie = CatsTrie(sentences)
    print(cats_trie.autocomplete('abc'))